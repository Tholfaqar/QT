#include "cad_to_path.h"
#include "ui_cad_to_path.h"
#include "classes.cpp"
#include "QList"
#include <QtCore>
#include <QtGui>
#include <QDir>
#include <QFileDialog>

CAD_to_path::CAD_to_path(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::CAD_to_path)
{
    ui->setupUi(this);
    ui->RobOffset_tb->setText("0.0 0.0 0.0 0.0 0.0 0.0");

    // classes creation

    // this is the resolution class for lines, circles and arches.
    // the way it works is: resolution means amount of points on a curve.
    // 1. line resolution: is the amount of points (or segments) in each line.
    // 2. circle resolution: the amount of degree increments along the circumference of the circle
    // 3. arc reolution: the amount in degree increments along the arch. similar to circle resolution since arch is a special case of circle.
    // example 1: if you set line_res = 10 (default), then you will have 10 points in the line.
    // example 2: the total degrees in a circle is 360. if you have circ_res = 1 (default), means you move along the circumference each 1 degree.
    // means you will have the full 360 points on the circumference of the circle. while, if you set it to 2, you will have only 180 points (360/2).
    // example 3: you have an arc, start angle = 10, end angle=60. you have 60-10 degrees.
    // if you choose arc_res = 1, then you will have (60-10)/1= 50 points on the arc. if arc_res =2, then (60-10)/2= 25 points (half the res of arc_res=1).
}
Path path1;
Rob_base_offset RBO1;
Point Pt1;
//QString filename;
CAD_to_path::~CAD_to_path()
{
    delete ui;
}

void CAD_to_path::on_browse_bn_clicked()
{
    path1.folder_path = QFileDialog::getOpenFileName(this,
            tr("Open DXF File"),"C://Users/","DXF Files (*.dxf)");
    ui->FilePath_tb->setText(path1.folder_path);
}

void CAD_to_path::on_gen_pg_bn_clicked()
{

}

void CAD_to_path::generate_pg(){
    /*
    QString message;
    QString caption;

                double dx, dy = 0.0;
                //program line counter
                int lines_count = 0;
                int max_pts_count = 0;
                int cad_line_count, cad_circle_count, cad_arc_count;
                int shape_count = 0;
                bool new_shape = true;
                //general counters
                int i, j, k;
                double prv_x = 0.0, prv_y = 0.0;
                //int max_i = 9;
                //points counter
                int int_pt = 0;
                //to convert points to string
                QString str_pt, line1;
                //string for header, line we read, x,y,z,... point coordinates
                QString header, line; //, x1, y1, z1, x2, y2, z2, yaw, pitch, roll;
                // this string array will hold program lines, size of 1000
                //string[] lines = new string[35000];
                QList<QString> lines;

                // check to see if the extended array locations have been selected
                //if (CB_ext_array.Checked == true) max_pts_count = 360000;
                if (ui->ex_array->checkState() == true) max_pts_count = 360000;
                else max_pts_count = 1200;

                // write program header to the program string "lines"
                line1 = ".PROGRAM MoveX_demo()";
                //lines.push_back(line1);
                lines.push_back(line1);
                lines_count++;
                line1 = "; ";
                lines.push_back(line1);
                lines_count++;
                line1 = "; this program was generated by MoveX_UI API";
                lines.push_back(line1);
                lines_count++;
                line1 = "; all rights reserved, Omron Adept Technologies";
                lines.push_back(line1);
                lines_count++;
                line1 = "; ";
                lines.push_back(line1);
                lines_count++;

                line1 = "; Robot base offset applied: " + ui->RobOffset_tb->textChanged(); //Rob_base_offset_TB.Text;

                lines.push_back(line1);
                lines_count++;

                line1 = ";  ";
                lines.push_back(line1);
                lines_count++;

                line1 = "; File path: " + path1.dxf_file_path;
                lines.push_back(line1);
                lines_count++;
                line1 = ";  ";
                lines.push_back(line1);
                lines_count++;

                System.IO.StreamReader file = new System.IO.StreamReader(path1.dxf_file_path);
                cad_line_count = 0;
                cad_circle_count = 0;
                cad_arc_count = 0;

                while ((line = file.ReadLine()) != null)
                {
                    //reading lines, single or multiple
                    if (line == "AcDbLine")
                    {
                        cad_line_count++;
                        //read x1 header
                        header = file.ReadLine();
                        //read x1 value
                        Pt1.x1 = Convert.ToDouble(file.ReadLine());

                        //read y1 header
                        header = file.ReadLine();
                        //read y1 value
                        Pt1.y1 = Convert.ToDouble(file.ReadLine());

                        //read z1 header
                        header = file.ReadLine();
                        //read z1 value
                        Pt1.z1 = Convert.ToDouble(file.ReadLine());

                        //read x2 header
                        header = file.ReadLine();
                        //read x2 value
                        Pt1.x2 = Convert.ToDouble(file.ReadLine());

                        //read y2 header
                        header = file.ReadLine();
                        //read y2 value
                        Pt1.y2 = Convert.ToDouble(file.ReadLine());

                        //read z2 header
                        header = file.ReadLine();
                        //read z2 value
                        Pt1.z2 = Convert.ToDouble(file.ReadLine());

                        //l = Math.Sqrt(Math.Pow((Pt1.x1 - Pt1.x4), 2) + Math.Pow((Pt1.y1 - Pt1.y4), 2));
                        //dl = l / 10;
                        dx = Math.Abs(Pt1.x1 - Pt1.x2) / Res1.line_res;
                        dy = Math.Abs(Pt1.y1 - Pt1.y2) / Res1.line_res;

                        //applying offset to each start/end point of the line.
                        Pt1.x1 = RBO1.x_off + Pt1.x1;
                        Pt1.y1 = RBO1.y_off + Pt1.y1;
                        Pt1.z1 = RBO1.z_off + Pt1.z1;

                        Pt1.x2 = RBO1.x_off + Pt1.x2;
                        Pt1.y2 = RBO1.y_off + Pt1.y2;
                        Pt1.z2 = RBO1.z_off + Pt1.z2;

                        Pt1.yaw = RBO1.yaw_off;
                        Pt1.pitch = RBO1.pitch_off;
                        Pt1.roll = RBO1.roll_off;
                        // setting up prv_x and prv_y
                        if (new_shape == true)
                        {
                            prv_x = Pt1.x1;
                            prv_x = Pt1.y1;
                            new_shape = false;
                            int_pt = 0;
                        }
                        //adding shape type as a comment.
                        line1 = " ";
                        lines.push_back(line1);
                        lines_count++;
                        line1 = "; Line " + cad_line_count.ToString();
                        lines.push_back(line1);
                        lines_count++;

                        if (Pt1.x1 < Pt1.x2 && Pt1.y1 < Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x1.ToString() + ", " + Pt1.y1.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                Pt1.x = Pt1.x + dx;
                                Pt1.y = Pt1.y + dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 < Pt1.x2 && Pt1.y1 > Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                Pt1.x = Pt1.x + dx;
                                Pt1.y = Pt1.y - dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 > Pt1.x2 && Pt1.y1 < Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                Pt1.x = Pt1.x - dx;
                                Pt1.y = Pt1.y + dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 > Pt1.x2 && Pt1.y1 > Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                Pt1.x = Pt1.x - dx;
                                Pt1.y = Pt1.y - dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 == Pt1.x2 && Pt1.y1 > Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                //Pt1.x = Pt1.x - dx;
                                Pt1.y = Pt1.y - dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 == Pt1.x2 && Pt1.y1 < Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                //Pt1.x = Pt1.x - dx;
                                Pt1.y = Pt1.y + dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 > Pt1.x2 && Pt1.y1 == Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                Pt1.x = Pt1.x - dx;
                                //Pt1.y = Pt1.y - dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 < Pt1.x2 && Pt1.y1 == Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                Pt1.x = Pt1.x + dx;
                                //Pt1.y = Pt1.y - dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                 ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if ((String.Equals(file.ReadLine(), "  0", StringComparison.OrdinalIgnoreCase)) == true)
                        {
                            if ((String.Equals(file.ReadLine(), "ENDSEC", StringComparison.OrdinalIgnoreCase)) == true)
                            {
                                //add the last point in the last line
                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x2.ToString() + ", " + Pt1.y2.ToString() + ", " + Pt1.z2.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (int_pt > max_pts_count)
                        {
                            message = "Error generating program. No. of points exceeded max allowed Edit your DXF or reduce resolution";
                            caption = "Unsuccessful";
                            MessageBoxButtons buttons2 = MessageBoxButtons.OK;
                            DialogResult result2;

                            // Displays the MessageBox.
                            result2 = MessageBox.Show(this, message, caption, buttons2,
                                MessageBoxIcon.Error, MessageBoxDefaultButton.Button1,
                                MessageBoxOptions.RtlReading);

                            if (result2 == DialogResult.OK)
                            {
                                return;
                            }
                        }
                        if (Pt1.x2 == prv_x && Pt1.y2 == prv_y)
                        {
                            shape_count++;
                            new_shape = true;
                            int_pt = 0;
                        }
                        else new_shape = false;

                    }

                    //reading ploylines (Polygons)
                    if (line == "AcDbPolyline")
                    {

                        //reading section headers
                        for (i = 0; i < 6; i++) header = file.ReadLine();
                        j = 0;
                        while ((String.Equals(line = file.ReadLine(), "  0", StringComparison.OrdinalIgnoreCase)) == false)
                        {
                            //cad_line_count++;
                            //read x1 value
                            Pt1.poly_pts[j, 0] = Convert.ToDouble(file.ReadLine());

                            //read y1 header
                            header = file.ReadLine();
                            //read y1 value
                            Pt1.poly_pts[j, 1] = Convert.ToDouble(file.ReadLine());
                            j++;
                        }

                        for (k = 0; k < j - 1; k++)
                        {
                            Pt1.x1 = Pt1.poly_pts[k, 0];
                            Pt1.y1 = Pt1.poly_pts[k, 1];

                            Pt1.x2 = Pt1.poly_pts[k + 1, 0];
                            Pt1.y2 = Pt1.poly_pts[k + 1, 1];

                            dx = Math.Abs(Pt1.x1 - Pt1.x2) / 10;
                            dy = Math.Abs(Pt1.y1 - Pt1.y2) / 10;

                            //applying offset to each point of the line.
                            Pt1.z1 = 0.0;
                            Pt1.z2 = 0.0;
                            Pt1.x1 = RBO1.x_off + Pt1.x1;
                            Pt1.y1 = RBO1.y_off + Pt1.y1;
                            Pt1.z1 = RBO1.z_off + Pt1.z1;

                            Pt1.x2 = RBO1.x_off + Pt1.x2;
                            Pt1.y2 = RBO1.y_off + Pt1.y2;
                            Pt1.z2 = RBO1.z_off + Pt1.z2;

                            Pt1.yaw = RBO1.yaw_off;
                            Pt1.pitch = RBO1.pitch_off;
                            Pt1.roll = RBO1.roll_off;

                            //line1= "  ";
                            //lines.push_back(line1);
                            //lines_count++;

                            //adding shape type as a comment
                            line1 = " ";
                            lines.push_back(line1);
                            lines_count++;
                            cad_line_count++;
                            line1 = "; Line " + cad_line_count;
                            lines.push_back(line1);
                            lines_count++;

                            if (Pt1.x1 < Pt1.x2 && Pt1.y1 < Pt1.y2)
                            {
                                Pt1.x = Pt1.x1;
                                Pt1.y = Pt1.y1;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;

                                for (i = 0; i < Res1.line_res - 1; i++)
                                {
                                    Pt1.x = Pt1.x + dx;
                                    Pt1.y = Pt1.y + dy;

                                    str_pt = int_pt.ToString();
                                    line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                    ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                    lines.push_back(line1);
                                    lines_count++;
                                    int_pt++;
                                }
                            }

                            if (Pt1.x1 < Pt1.x2 && Pt1.y1 > Pt1.y2)
                            {
                                Pt1.x = Pt1.x1;
                                Pt1.y = Pt1.y1;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;

                                for (i = 0; i < Res1.line_res - 1; i++)
                                {
                                    Pt1.x = Pt1.x + dx;
                                    Pt1.y = Pt1.y - dy;

                                    str_pt = int_pt.ToString();
                                    line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                    ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                    lines.push_back(line1);
                                    lines_count++;
                                    int_pt++;
                                }
                            }

                            if (Pt1.x1 > Pt1.x2 && Pt1.y1 < Pt1.y2)
                            {
                                Pt1.x = Pt1.x1;
                                Pt1.y = Pt1.y1;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;

                                for (i = 0; i < Res1.line_res - 1; i++)
                                {
                                    Pt1.x = Pt1.x - dx;
                                    Pt1.y = Pt1.y + dy;

                                    str_pt = int_pt.ToString();
                                    line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                    ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                    lines.push_back(line1);
                                    lines_count++;
                                    int_pt++;
                                }
                            }

                            if (Pt1.x1 > Pt1.x2 && Pt1.y1 > Pt1.y2)
                            {
                                Pt1.x = Pt1.x1;
                                Pt1.y = Pt1.y1;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;

                                for (i = 0; i < Res1.line_res - 1; i++)
                                {
                                    Pt1.x = Pt1.x - dx;
                                    Pt1.y = Pt1.y - dy;

                                    str_pt = int_pt.ToString();
                                    line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                    ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                    lines.push_back(line1);
                                    lines_count++;
                                    int_pt++;
                                }
                            }

                            if (Pt1.x1 == Pt1.x2 && Pt1.y1 > Pt1.y2)
                            {
                                Pt1.x = Pt1.x1;
                                Pt1.y = Pt1.y1;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;

                                for (i = 0; i < Res1.line_res - 1; i++)
                                {
                                    //Pt1.x = Pt1.x - dx;
                                    Pt1.y = Pt1.y - dy;

                                    str_pt = int_pt.ToString();
                                    line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                    ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                    lines.push_back(line1);
                                    lines_count++;
                                    int_pt++;
                                }
                            }

                            if (Pt1.x1 == Pt1.x2 && Pt1.y1 < Pt1.y2)
                            {
                                Pt1.x = Pt1.x1;
                                Pt1.y = Pt1.y1;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;

                                for (i = 0; i < Res1.line_res - 1; i++)
                                {
                                    //Pt1.x = Pt1.x - dx;
                                    Pt1.y = Pt1.y + dy;

                                    str_pt = int_pt.ToString();
                                    line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                    ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                    lines.push_back(line1);
                                    lines_count++;
                                    int_pt++;
                                }
                            }

                            if (Pt1.x1 > Pt1.x2 && Pt1.y1 == Pt1.y2)
                            {
                                Pt1.x = Pt1.x1;
                                Pt1.y = Pt1.y1;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;

                                for (i = 0; i < Res1.line_res - 1; i++)
                                {
                                    Pt1.x = Pt1.x - dx;
                                    //Pt1.y = Pt1.y - dy;

                                    str_pt = int_pt.ToString();
                                    line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                    ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                    lines.push_back(line1);
                                    lines_count++;
                                    int_pt++;
                                }
                            }

                            if (Pt1.x1 < Pt1.x2 && Pt1.y1 == Pt1.y2)
                            {
                                Pt1.x = Pt1.x1;
                                Pt1.y = Pt1.y1;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;

                                for (i = 0; i < Res1.line_res - 1; i++)
                                {
                                    Pt1.x = Pt1.x + dx;
                                    //Pt1.y = Pt1.y - dy;

                                    str_pt = int_pt.ToString();
                                    line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                    ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                    lines.push_back(line1);
                                    lines_count++;
                                    int_pt++;
                                }
                            }

                        }
                        // add the last line between 1st point in first line and last point in last line
                        cad_line_count++;
                        Pt1.x1 = Pt1.poly_pts[j - 1, 0];
                        Pt1.y1 = Pt1.poly_pts[j - 1, 1];

                        Pt1.x2 = Pt1.poly_pts[0, 0];
                        Pt1.y2 = Pt1.poly_pts[0, 1];

                        dx = Math.Abs(Pt1.x1 - Pt1.x2) / Res1.line_res;
                        dy = Math.Abs(Pt1.y1 - Pt1.y2) / Res1.line_res;

                        //applying offset to each start/end point of the line.
                        Pt1.z1 = 0.0;
                        Pt1.z2 = 0.0;
                        Pt1.x1 = RBO1.x_off + Pt1.x1;
                        Pt1.y1 = RBO1.y_off + Pt1.y1;
                        Pt1.z1 = RBO1.z_off + Pt1.z1;

                        Pt1.x2 = RBO1.x_off + Pt1.x2;
                        Pt1.y2 = RBO1.y_off + Pt1.y2;
                        Pt1.z2 = RBO1.z_off + Pt1.z2;

                        Pt1.yaw = RBO1.yaw_off;
                        Pt1.pitch = RBO1.pitch_off;
                        Pt1.roll = RBO1.roll_off;

                        line1 = "; Line " + cad_line_count.ToString();
                        lines.push_back(line1);
                        lines_count++;

                        if (Pt1.x1 < Pt1.x2 && Pt1.y1 < Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                Pt1.x = Pt1.x + dx;
                                Pt1.y = Pt1.y + dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 < Pt1.x2 && Pt1.y1 > Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                Pt1.x = Pt1.x + dx;
                                Pt1.y = Pt1.y - dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 > Pt1.x2 && Pt1.y1 < Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                Pt1.x = Pt1.x - dx;
                                Pt1.y = Pt1.y + dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 > Pt1.x2 && Pt1.y1 > Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                Pt1.x = Pt1.x - dx;
                                Pt1.y = Pt1.y - dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 == Pt1.x2 && Pt1.y1 > Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                //Pt1.x = Pt1.x - dx;
                                Pt1.y = Pt1.y - dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 == Pt1.x2 && Pt1.y1 < Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                //Pt1.x = Pt1.x - dx;
                                Pt1.y = Pt1.y + dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 > Pt1.x2 && Pt1.y1 == Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                Pt1.x = Pt1.x - dx;
                                //Pt1.y = Pt1.y - dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1); ;
                                lines_count++;
                                int_pt++;
                            }
                        }

                        if (Pt1.x1 < Pt1.x2 && Pt1.y1 == Pt1.y2)
                        {
                            Pt1.x = Pt1.x1;
                            Pt1.y = Pt1.y1;

                            str_pt = int_pt.ToString();
                            line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                            lines.push_back(line1);
                            lines_count++;
                            int_pt++;

                            for (i = 0; i < Res1.line_res - 1; i++)
                            {
                                Pt1.x = Pt1.x + dx;
                                //Pt1.y = Pt1.y - dy;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x.ToString() + ", " + Pt1.y.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                        }
                        if (int_pt > max_pts_count)
                        {
                            message = "Error generating program. No. of points exceeded max allowed Edit your DXF or reduce resolution";
                            caption = "Unsuccessful";
                            MessageBoxButtons buttons3 = MessageBoxButtons.OK;
                            DialogResult result3;

                            // Displays the MessageBox.
                            result3 = MessageBox.Show(this, message, caption, buttons3,
                                MessageBoxIcon.Error, MessageBoxDefaultButton.Button1,
                                MessageBoxOptions.RtlReading);

                            if (result3 == DialogResult.OK)
                            {
                                return;
                            }
                        }
                        shape_count++;
                        new_shape = true;
                        int_pt = 0;
                    }

                    //reading circles
                    if (line == "AcDbCircle")
                    {
                        cad_circle_count++;
                        //coordinates (cx,cy,cz) for the center of the circle and cr as circle radius
                        double cx, cy, cz, cr;
                        int max_pts = 360;
                        //point (x,y) on the circumference of the circle
                        double x, y;

                        //read cx header
                        header = file.ReadLine();
                        //read cx value
                        cx = Convert.ToDouble(file.ReadLine());

                        //read cy header
                        header = file.ReadLine();
                        //read cy value
                        cy = Convert.ToDouble(file.ReadLine());

                        //read cz header
                        header = file.ReadLine();
                        //read cz value
                        cz = Convert.ToDouble(file.ReadLine());

                        //read r header
                        header = file.ReadLine();
                        //read r (radius) value
                        cr = Convert.ToDouble(file.ReadLine());

                        // equation of the circle
                        // x = cx + r * cos(a)
                        // y = cy + r * sin(a)
                        // Where r is the radius, cx,cy the origin, and ang is the angle.

                        header = file.ReadLine();
                        line1 = " ";
                        lines.push_back(line1);
                        lines_count++;
                        //max_pts = 360;
                        // reading arcs, since its a special case of a circle.
                        if ((line = file.ReadLine()) == "AcDbArc")
                        {
                            cad_arc_count++;
                            double start_ang, end_ang;
                            //string str_strt_ang, str_end_ang;
                            int i_st, i_en;
                            // start ang header
                            header = file.ReadLine();
                            //read start ang value
                            start_ang = Convert.ToDouble(file.ReadLine());

                            //read end ang header
                            header = file.ReadLine();
                            //read end ang value
                            end_ang = Convert.ToDouble(file.ReadLine());

                            //start_ang = Convert.ToDouble(str_strt_ang);
                            //end_ang = Convert.ToDouble(str_end_ang);
                            i_st = Convert.ToInt32(start_ang);
                            i_en = Convert.ToInt32(end_ang);

                            //adding shape type as a comment
                            line1 = "; Arc " + cad_arc_count.ToString();
                            lines.push_back(line1);
                            lines_count++;
                            // shape is arc
                            if (i_st < i_en)
                            {
                                for (i = i_en; i > i_st; i -= Res1.arc_res)
                                {
                                    x = cx + cr * Math.Cos(i * Math.PI / 180);
                                    y = cy + cr * Math.Sin(i * Math.PI / 180);

                                    Pt1.x1 = RBO1.x_off + x; //Convert.ToDouble(Pt1.str_x1);
                                    Pt1.y1 = RBO1.y_off + y; //Convert.ToDouble(Pt1.str_y1);
                                    Pt1.z1 = RBO1.z_off;     //Convert.ToDouble(Pt1.str_z1);
                                    Pt1.yaw = RBO1.yaw_off;
                                    Pt1.pitch = RBO1.pitch_off;
                                    Pt1.roll = RBO1.roll_off;

                                    str_pt = int_pt.ToString();
                                    line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x1.ToString() + ", " + Pt1.y1.ToString() + ", " + Pt1.z1.ToString() +
                                    ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                    lines.push_back(line1);
                                    lines_count++;
                                    int_pt++;
                                }
                            }
                            else
                            {
                                for (i = i_en + 360; i > i_st; i -= Res1.arc_res)
                                {
                                    x = cx + cr * Math.Cos(i * Math.PI / 180);
                                    y = cy + cr * Math.Sin(i * Math.PI / 180);

                                    Pt1.x1 = RBO1.x_off + x; //Convert.ToDouble(Pt1.str_x1);
                                    Pt1.y1 = RBO1.y_off + y; //Convert.ToDouble(Pt1.str_y1);
                                    Pt1.z1 = RBO1.z_off;     //Convert.ToDouble(Pt1.str_z1);
                                    Pt1.yaw = RBO1.yaw_off;
                                    Pt1.pitch = RBO1.pitch_off;
                                    Pt1.roll = RBO1.roll_off;

                                    str_pt = int_pt.ToString();
                                    line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x1.ToString() + ", " + Pt1.y1.ToString() + ", " + Pt1.z1.ToString() +
                                    ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                    lines.push_back(line1);
                                    lines_count++;
                                    int_pt++;
                                }
                            }
                        }
                        else
                        { //shape is a circle
                          //adding shape type as a comment
                            line1 = "; Circle " + cad_circle_count.ToString();
                            lines.push_back(line1);
                            lines_count++;

                            shape_count++;
                            new_shape = true;
                            int_pt = 0;

                            for (i = 0; i < max_pts; i += Res1.circ_res)
                            {
                                x = cx + cr * Math.Cos(i * Math.PI / 180);
                                y = cy + cr * Math.Sin(i * Math.PI / 180);

                                Pt1.x1 = RBO1.x_off + x; //Convert.ToDouble(Pt1.str_x1);
                                Pt1.y1 = RBO1.y_off + y; //Convert.ToDouble(Pt1.str_y1);
                                Pt1.z1 = RBO1.z_off;     //Convert.ToDouble(Pt1.str_z1);
                                Pt1.yaw = RBO1.yaw_off;
                                Pt1.pitch = RBO1.pitch_off;
                                Pt1.roll = RBO1.roll_off;

                                str_pt = int_pt.ToString();
                                line1 = "SET array.loc" + shape_count.ToString() + "[" + str_pt + "] = TRANS(" + Pt1.x1.ToString() + ", " + Pt1.y1.ToString() + ", " + Pt1.z1.ToString() +
                                ", " + Pt1.yaw.ToString() + ", " + Pt1.pitch.ToString() + ", " + Pt1.roll.ToString() + ")";
                                lines.push_back(line1);
                                lines_count++;
                                int_pt++;
                            }
                            if (int_pt > max_pts_count)
                            {
                                message = "Error generating program. No. of points exceeded max allowed Edit your DXF or reduce resolution";
                                caption = "Unsuccessful";
                                MessageBoxButtons buttons5 = MessageBoxButtons.OK;
                                DialogResult result5;

                                // Displays the MessageBox.
                                result5 = MessageBox.Show(this, message, caption, buttons5,
                                    MessageBoxIcon.Error, MessageBoxDefaultButton.Button1,
                                    MessageBoxOptions.RtlReading);

                                if (result5 == DialogResult.OK)
                                {
                                    return;
                                }
                            }
                            shape_count++;
                            int_pt = 0;
                        }
                        if (int_pt > max_pts_count)
                        {
                            message = "Error generating program. No. of points exceeded max allowed Edit your DXF or reduce resolution";
                            caption = "Unsuccessful";
                            MessageBoxButtons buttons5 = MessageBoxButtons.OK;
                            DialogResult result5;

                            // Displays the MessageBox.
                            result5 = MessageBox.Show(this, message, caption, buttons5,
                                MessageBoxIcon.Error, MessageBoxDefaultButton.Button1,
                                MessageBoxOptions.RtlReading);

                            if (result5 == DialogResult.OK)
                            {
                                return;
                            }
                        }
                    }
                    if (int_pt > max_pts_count)
                    {
                        message = "Error generating program. No. of points exceeded max allowed Edit your DXF or reduce resolution";
                        caption = "Unsuccessful";
                        MessageBoxButtons buttons6 = MessageBoxButtons.OK;
                        DialogResult result6;

                        // Displays the MessageBox.
                        result6 = MessageBox.Show(this, message, caption, buttons6,
                            MessageBoxIcon.Error, MessageBoxDefaultButton.Button1,
                            MessageBoxOptions.RtlReading);

                        if (result6 == DialogResult.OK)
                        {
                            return;
                        }
                    }
                }
                // adding global arrays to the top of the list
                string str_i;
                for (i = 0; i <= shape_count; i++)
                {
                    str_i = i.ToString();
                    line1 = "GLOBAL array.loc" + str_i + "[] ";
                    lines.Insert(i + 9, line1);
                    lines_count++;
                    line1 = "MCS \"DELETEL array.loc" + str_i + "[]\" ";
                    lines.Insert(i + 10, line1);
                    lines_count++;
                }

                line1 = " ";
                lines.push_back(line1);
                lines_count++;
                line1 = "SPEED 20 ALWAYS ";
                lines.push_back(line1);
                lines_count++;
                line1 = "ACCEL 30,30 ";
                lines.push_back(line1);
                lines_count++;
                line1 = " ";
                lines.push_back(line1);
                lines_count++;

                for (i = 0; i <= shape_count; i++)
                {
                    // check to see which movement mode have been selected
                    if (RB_Cart.Checked == true)
                    {
                        if (CB_ext_array.Checked == true)
                        {
                            if (RB_Mode1.Checked == true)
                            {
                                line1 = "MOVEX ,array.loc" + i.ToString() + "[],,1,1,1";
                                lines.push_back(line1);
                                lines_count++;
                            }
                            else if (RB_Mode2.Checked == true)
                            {
                                line1 = "MOVEX ,array.loc" + i.ToString() + "[],,1,2,1";
                                lines.push_back(line1);
                                lines_count++;
                            }
                            else if (RB_Mode3.Checked == true)
                            {
                                line1 = "MOVEX ,array.loc" + i.ToString() + "[],,1,3,1";
                                lines.push_back(line1);
                                lines_count++;
                            }
                        }
                        else //extended array was not chosen
                        {
                            if (RB_Mode1.Checked == true)
                            {
                                line1 = "MOVEX ,array.loc" + i.ToString() + "[],,1,1,";
                                lines.push_back(line1);
                                lines_count++;
                            }
                            else if (RB_Mode2.Checked == true)
                            {
                                line1 = "MOVEX ,array.loc" + i.ToString() + "[],,1,2,";
                                lines.push_back(line1);
                                lines_count++;
                            }
                            else if (RB_Mode3.Checked == true)
                            {
                                line1 = "MOVEX ,array.loc" + i.ToString() + "[],,1,3,";
                                lines.push_back(line1);
                                lines_count++;
                            }
                        }
                    }
                    else // Chartisian movement not selected, hence Angular selected
                    {
                        // check to see which movement mode have been selected
                        if (CB_ext_array.Checked == true)
                        {
                            if (RB_Mode1.Checked == true)
                            {
                                line1 = "MOVEX ,array.loc" + i.ToString() + "[],,2,1,1";
                                lines.push_back(line1);
                                lines_count++;
                            }
                            else if (RB_Mode2.Checked == true)
                            {
                                line1 = "MOVEX ,array.loc" + i.ToString() + "[],,2,2,1";
                                lines.push_back(line1);
                                lines_count++;
                            }
                            else if (RB_Mode3.Checked == true)
                            {
                                line1 = "MOVEX ,array.loc" + i.ToString() + "[],,2,3,1";
                                lines.push_back(line1);
                                lines_count++;
                            }
                        }
                        else //extended array was not chosen
                        {
                            if (RB_Mode1.Checked == true)
                            {
                                line1 = "MOVEX ,array.loc" + i.ToString() + "[],,2,1,";
                                lines.push_back(line1);
                                lines_count++;
                            }
                            else if (RB_Mode2.Checked == true)
                            {
                                line1 = "MOVEX ,array.loc" + i.ToString() + "[],,2,2,";
                                lines.push_back(line1);
                                lines_count++;
                            }
                            else if (RB_Mode3.Checked == true)
                            {
                                line1 = "MOVEX ,array.loc" + i.ToString() + "[],,2,3,";
                                lines.push_back(line1);
                                lines_count++;
                            }
                        }
                    }

                    //line1 = "MOVEX ,array.loc" + i.ToString() +"[],,,,1";
                    //lines.push_back(line1);
                    //lines_count++;
                    line1 = "BREAK";
                    lines.push_back(line1);
                    lines_count++;
                    line1 = " ";
                    lines.push_back(line1);
                    lines_count++;
                }

                line1 = ".END";
                lines.push_back(line1);

                System.IO.File.WriteAllLines(@path1.program_path, lines);
                file.Close();

                message = "Press OK to close window";
                caption = "Success";
                MessageBoxButtons buttons = MessageBoxButtons.OK;
                DialogResult result;

                // Displays the MessageBox.
                result = MessageBox.Show(this, message, caption, buttons,
                    MessageBoxIcon.None, MessageBoxDefaultButton.Button1,
                    MessageBoxOptions.RtlReading);

                if (result == DialogResult.OK)
                {
                    return;
                }
            }

            private void Exit_Click(object sender, EventArgs e)
            {
                this.Close();
            }

            private void Rob_base_offset_TB_TextChanged(object sender, EventArgs e)
            {

            }

            private void Rob_base_offset_TB_KeyDown(object sender, KeyEventArgs e)
            {
                if (e.KeyCode == Keys.Enter)
                {
                    int count = 0;
                    List<string> values = Rob_base_offset_TB.Text.Split(' ').ToList();
                    foreach (var value in values)
                    {
                        if (value.Length > 0)
                        {
                            try
                            {
                                //list.Add(double.Parse(elem, format));
                                RBO1.offset_array.Add(Convert.ToDouble(value));
                                count++;
                            }
                            catch (FormatException)
                            {
                                string message = "Error reading robot base offset, please enter numbers only";
                                string caption = "Unsuccessful";
                                MessageBoxButtons buttons1 = MessageBoxButtons.OK;
                                DialogResult result1;

                                // Displays the MessageBox.
                                result1 = MessageBox.Show(this, message, caption, buttons1,
                                          MessageBoxIcon.Error, MessageBoxDefaultButton.Button1,
                                          MessageBoxOptions.RtlReading);

                                if (result1 == DialogResult.OK)
                                {
                                    return;
                                }
                            }
                        }
                    }

                    if (count == 6)
                    {
                        RBO1.x_off = RBO1.offset_array[0];
                        RBO1.y_off = RBO1.offset_array[1];
                        RBO1.z_off = RBO1.offset_array[2];
                        RBO1.yaw_off = RBO1.offset_array[3];
                        RBO1.pitch_off = RBO1.offset_array[4];
                        RBO1.roll_off = RBO1.offset_array[5];
                        RBO1.offset_array.Clear();
                    }
                    else
                    {
                        string message = "Error reading robot base offset, please enter 6 values";
                        string caption = "Unsuccessful";
                        MessageBoxButtons buttons1 = MessageBoxButtons.OK;
                        DialogResult result1;

                        // Displays the MessageBox.
                        result1 = MessageBox.Show(this, message, caption, buttons1,
                                  MessageBoxIcon.Error, MessageBoxDefaultButton.Button1,
                                  MessageBoxOptions.RtlReading);

                        if (result1 == DialogResult.OK)
                        {
                            return;
                        }
                    }
                    Rob_base_offset_TB.Text = RBO1.x_off.ToString() + " " +
                                              RBO1.y_off.ToString() + " " +
                                              RBO1.z_off.ToString() + " " +
                                              RBO1.yaw_off.ToString() + " " +
                                              RBO1.pitch_off.ToString() + " " +
                                              RBO1.roll_off.ToString();
                }

                */


}
